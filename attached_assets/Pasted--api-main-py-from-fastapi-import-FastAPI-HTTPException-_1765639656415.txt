# api/main.py

from fastapi import FastAPI, HTTPException, Depends, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional
from datetime import date
import asyncpg

app = FastAPI(title="Claims IQ Estimation API", version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database connection
async def get_db():
    conn = await asyncpg.connect(DATABASE_URL)
    try:
        yield conn
    finally:
        await conn.close()

# ============================================
# SCHEMAS
# ============================================

class LineItemResponse(BaseModel):
    id: str
    code: str
    category_id: str
    category_name: str
    description: str
    unit: str
    base_price: float
    
class LineItemSearchResponse(BaseModel):
    items: list[LineItemResponse]
    total: int
    
class PriceCalculationRequest(BaseModel):
    line_item_code: str
    quantity: float
    region_id: str
    carrier_id: Optional[str] = None

class PriceBreakdown(BaseModel):
    material: float
    labor: float
    equipment: float
    
class PriceCalculationResponse(BaseModel):
    line_item_code: str
    quantity: float
    unit: str
    unit_price: float
    subtotal: float
    breakdown: PriceBreakdown
    region_id: str
    carrier_id: Optional[str]

class EstimateGenerateRequest(BaseModel):
    claim_id: str
    include_overhead: bool = True
    overhead_pct: float = 0.10
    profit_pct: float = 0.10

# ============================================
# LINE ITEMS ENDPOINTS
# ============================================

@app.get("/api/line-items", response_model=LineItemSearchResponse)
async def search_line_items(
    q: Optional[str] = Query(None, description="Search term"),
    category: Optional[str] = Query(None, description="Category ID filter"),
    damage_type: Optional[str] = Query(None, description="Filter by damage type trigger"),
    limit: int = Query(50, le=100),
    offset: int = Query(0),
    db = Depends(get_db)
):
    """Search and filter line items catalog."""
    
    conditions = ["li.is_active = true"]
    params = []
    param_idx = 1
    
    if q:
        conditions.append(f"""
            (li.code ILIKE ${param_idx} 
             OR li.description ILIKE ${param_idx}
             OR ${param_idx + 1} = ANY(li.tags))
        """)
        params.extend([f"%{q}%", q.lower()])
        param_idx += 2
        
    if category:
        conditions.append(f"(li.category_id = ${param_idx} OR li.category_id LIKE ${param_idx + 1})")
        params.extend([category, f"{category}.%"])
        param_idx += 2
        
    if damage_type:
        conditions.append(f"""
            EXISTS (
                SELECT 1 FROM jsonb_array_elements(li.scope_triggers) AS trigger
                WHERE trigger->>'damage_type' = ${param_idx}
            )
        """)
        params.append(damage_type)
        param_idx += 1
    
    where_clause = " AND ".join(conditions)
    
    # Get total count
    count_query = f"""
        SELECT COUNT(*) FROM line_items li WHERE {where_clause}
    """
    total = await db.fetchval(count_query, *params)
    
    # Get items
    query = f"""
        SELECT 
            li.id, li.code, li.category_id, li.description, li.unit,
            lic.name as category_name
        FROM line_items li
        JOIN line_item_categories lic ON li.category_id = lic.id
        WHERE {where_clause}
        ORDER BY li.category_id, li.code
        LIMIT ${param_idx} OFFSET ${param_idx + 1}
    """
    params.extend([limit, offset])
    
    rows = await db.fetch(query, *params)
    
    items = []
    for row in rows:
        # Calculate base price (simplified - would use full pricing engine)
        base_price = await calculate_base_price(db, row['code'], 'US-NATIONAL')
        items.append(LineItemResponse(
            id=str(row['id']),
            code=row['code'],
            category_id=row['category_id'],
            category_name=row['category_name'],
            description=row['description'],
            unit=row['unit'],
            base_price=base_price
        ))
    
    return LineItemSearchResponse(items=items, total=total)

@app.get("/api/line-items/categories")
async def get_categories(db = Depends(get_db)):
    """Get all line item categories."""
    rows = await db.fetch("""
        SELECT id, parent_id, name, description, sort_order
        FROM line_item_categories
        ORDER BY sort_order, id
    """)
    return [dict(row) for row in rows]

# ============================================
# PRICING ENDPOINTS
# ============================================

@app.post("/api/pricing/calculate", response_model=PriceCalculationResponse)
async def calculate_price(
    request: PriceCalculationRequest,
    db = Depends(get_db)
):
    """Calculate price for a line item with regional and carrier adjustments."""
    
    # Get line item
    line_item = await db.fetchrow("""
        SELECT * FROM line_items WHERE code = $1 AND is_active = true
    """, request.line_item_code)
    
    if not line_item:
        raise HTTPException(404, f"Line item {request.line_item_code} not found")
    
    # Get region
    region = await db.fetchrow("""
        SELECT * FROM regions WHERE id = $1
    """, request.region_id)
    
    if not region:
        raise HTTPException(404, f"Region {request.region_id} not found")
    
    # Calculate material cost
    material_cost = await calculate_material_cost(
        db, 
        line_item['material_components'], 
        request.region_id
    )
    
    # Calculate labor cost  
    labor_cost = await calculate_labor_cost(
        db,
        line_item['labor_components'],
        request.region_id
    )
    
    # Calculate equipment cost
    equipment_cost = calculate_equipment_cost(line_item['equipment_components'])
    
    # Apply waste factor
    material_cost *= float(line_item['waste_factor'])
    
    # Unit price
    unit_price = material_cost + labor_cost + equipment_cost
    
    # Apply carrier adjustments if specified
    if request.carrier_id:
        carrier = await db.fetchrow("""
            SELECT * FROM carrier_profiles WHERE id = $1
        """, request.carrier_id)
        
        if carrier:
            unit_price = apply_carrier_adjustments(
                unit_price, 
                carrier, 
                line_item['category_id'],
                request.region_id
            )
    
    # Calculate totals
    subtotal = unit_price * request.quantity
    subtotal = max(subtotal, float(line_item['minimum_charge']))
    
    return PriceCalculationResponse(
        line_item_code=request.line_item_code,
        quantity=request.quantity,
        unit=line_item['unit'],
        unit_price=round(unit_price, 2),
        subtotal=round(subtotal, 2),
        breakdown=PriceBreakdown(
            material=round(material_cost * request.quantity, 2),
            labor=round(labor_cost * request.quantity, 2),
            equipment=round(equipment_cost * request.quantity, 2)
        ),
        region_id=request.region_id,
        carrier_id=request.carrier_id
    )

@app.get("/api/pricing/region/{zip_code}")
async def get_region_by_zip(zip_code: str, db = Depends(get_db)):
    """Get pricing region for a ZIP/postal code."""
    
    # Try to match by prefix
    prefix = zip_code[:3]
    
    region = await db.fetchrow("""
        SELECT * FROM regions 
        WHERE $1 = ANY(zip_postal_prefixes)
        LIMIT 1
    """, prefix)
    
    if not region:
        # Fall back to national average
        region = await db.fetchrow("""
            SELECT * FROM regions WHERE id = 'US-NATIONAL'
        """)
    
    return dict(region)

# ============================================
# HELPER FUNCTIONS
# ============================================

async def calculate_base_price(db, line_item_code: str, region_id: str) -> float:
    """Calculate base price for a line item in a region."""
    
    line_item = await db.fetchrow("""
        SELECT * FROM line_items WHERE code = $1
    """, line_item_code)
    
    if not line_item:
        return 0.0
    
    material = await calculate_material_cost(db, line_item['material_components'], region_id)
    labor = await calculate_labor_cost(db, line_item['labor_components'], region_id)
    equipment = calculate_equipment_cost(line_item['equipment_components'])
    
    return round((material + labor + equipment) * float(line_item['waste_factor']), 2)

async def calculate_material_cost(db, components: list, region_id: str) -> float:
    """Calculate total material cost from components."""
    import json
    
    if isinstance(components, str):
        components = json.loads(components)
    
    total = 0.0
    for comp in components:
        # Try regional price first
        price_row = await db.fetchrow("""
            SELECT mrp.price 
            FROM material_regional_prices mrp
            JOIN materials m ON m.id = mrp.material_id
            WHERE m.sku = $1 AND mrp.region_id = $2
            ORDER BY mrp.effective_date DESC
            LIMIT 1
        """, comp['sku'], region_id)
        
        if price_row:
            price = float(price_row['price'])
        else:
            # Fall back to base price
            base_row = await db.fetchrow("""
                SELECT base_price FROM materials WHERE sku = $1
            """, comp['sku'])
            price = float(base_row['base_price']) if base_row else 0
        
        total += price * comp['qty_per_unit']
    
    return total

async def calculate_labor_cost(db, components: list, region_id: str) -> float:
    """Calculate total labor cost from components."""
    import json
    
    if isinstance(components, str):
        components = json.loads(components)
    
    # Get region indices
    region = await db.fetchrow("SELECT indices FROM regions WHERE id = $1", region_id)
    indices = region['indices'] if region else {}
    
    total = 0.0
    for comp in components:
        trade = comp.get('trade', 'general')
        
        # Get base rate
        rate_row = await db.fetchrow("""
            SELECT hourly_rate FROM labor_rates 
            WHERE region_id = 'US-NATIONAL' AND trade = $1
            ORDER BY effective_date DESC LIMIT 1
        """, trade)
        
        base_rate = float(rate_row['hourly_rate']) if rate_row else 45.0
        
        # Apply regional index
        index_key = f"labor_{trade}"
        regional_index = float(indices.get(index_key, indices.get('labor_general', 1.0)))
        
        adjusted_rate = base_rate * regional_index
        total += adjusted_rate * comp['hours_per_unit']
    
    return total

def calculate_equipment_cost(components: list) -> float:
    """Calculate equipment cost from components."""
    import json
    
    if isinstance(components, str):
        components = json.loads(components)
    
    return sum(comp.get('cost_per_unit', 0) for comp in components)

def apply_carrier_adjustments(
    unit_price: float, 
    carrier: dict, 
    category_id: str, 
    region_id: str
) -> float:
    """Apply carrier-specific price adjustments."""
    
    # Global adjustment
    adjusted = unit_price * float(carrier.get('labor_adjustment_factor', 1.0))
    
    # Category adjustment
    category_adj = carrier.get('category_adjustments', {})
    if category_id in category_adj:
        adjusted *= float(category_adj[category_id].get('factor', 1.0))
    
    # Regional adjustment
    regional_adj = carrier.get('regional_adjustments', {})
    for pattern, adj in regional_adj.items():
        if region_id.startswith(pattern.replace('*', '')):
            adjusted *= float(adj.get('factor', 1.0))
            break
    
    return adjusted

# ============================================
# RUN
# ============================================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
